多态的实现原理
多态是面向对象编程中的一个重要概念，它允许同一接口使用不同的实现。多态的实现方式主要分为静态多态和动态多态。

1. 静态多态
静态多态是在编译期间确定的，也称为编译时多态。主要通过以下两种方式实现：

函数重载（Function Overloading）：

函数重载允许同一个函数名有不同的参数列表（参数个数或类型不同）。

注意： 不能通过返回值类型来区别重载


编译器根据函数调用时提供的参数类型和数量，在编译时选择正确的函数版本。
示例：
```C++
void print(int i) {
    std::cout << "Integer: " << i << std::endl;
}

void print(double d) {
    std::cout << "Double: " << d << std::endl;
}

void print(std::string s) {
    std::cout << "String: " << s << std::endl;
}

在上述例子中，print函数被重载了三个版本，编译器会根据传入参数的类型选择合适的print函数。

模板（Templates）：-- 包括 类模板 和 函数模板

模板允许编写泛型代码，可以根据不同的类型实例化出不同的函数或类。


编译器在编译时根据具体的类型实例化模板，生成相应的代码。
示例：
template <typename T>
T add(T a, T b) {
    return a + b;
}
这里的add函数是一个模板函数，可以在编译时根据传入的类型实例化为处理不同类型（如int、double等）的函数。


2. 动态多态
动态多态是在运行期间确定的，也称为运行时多态，主要通过继承和虚函数实现。动态多态的核心机制是虚函数表（vtable）。

虚函数（Virtual Functions）：

在基类中声明为virtual的函数可以在派生类中被重写。通过基类指针或引用调用这些函数时，会根据实际对象的类型选择调用哪个函数版本。
示例：
class Base {
public:
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->show();  // 输出 "Derived class"
    delete basePtr;
    return 0;
}
在这个例子中，通过基类指针basePtr调用show函数时，会根据实际对象的类型（Derived类）选择调用Derived类的show函数。

虚函数表（vtable）：

虚函数表是每个含有虚函数的类在编译时生成的一个表格，里面存储了该类的所有虚函数的地址。
每个对象内部有一个指向虚函数表的指针（vptr）。当通过基类指针调用虚函数时，程序会先通过对象的vptr找到对应的虚函数表，然后从虚函数表中找到对应的函数地址并进行调用。
例如，当基类指针指向派生类对象时，vptr会指向派生类的虚函数表，调用虚函数时，会调用派生类的函数版本，从而实现多态。

面试时常问的问题

静态多态与动态多态的区别？

静态多态在编译时决定，动态多态在运行时决定。静态多态通过函数重载和模板实现，动态多态通过虚函数和继承实现。
如何实现动态多态？

通过继承和虚函数，基类中的虚函数可以在派生类中被重写。在运行时，通过基类指针或引用，可以动态选择调用派生类的函数版本。

虚函数表的作用是什么？

虚函数表存储了类的虚函数的地址。
当使用基类指针调用虚函数时，通过虚函数表动态选择调用派生类的函数版本，从而实现多态。

为什么需要多态？

多态允许使用统一的接口来处理不同类型的对象，提高了代码的灵活性和可维护性。

虚函数表指针的开销是什么？

每个含有虚函数的对象中包含一个额外的指针（vptr）指向虚函数表，这增加了对象的大小。
此外，调用虚函数时，需要一次额外的间接跳转，这比直接调用函数稍微慢一些。
```
==============================================================================
==============================================================================

动态多态实现过程： 
    带 virtual 关键字函数的类及其子类(复写这些virtual关键字所对应的函数), 在编译过程中生成它们的虚函数表
    在运行时, 根据指针或引用(也可以具备多态)指向的实际对象, 从虚函数表中选择函数调用

===============================================================================
===============================================================================

#### 为什么--不能通过返回值类型来区别重载

为了使函数重载合法，必须确保函数的参数列表（参数的数量、类型或顺序）有所不同。以下是一些详细的说明和示例。

1. 函数重载的规则
C++支持函数重载，但它的规则要求函数的参数列表必须有所区别。具体来说，以下几点可以区分重载函数：

参数的数量不同。
参数的类型不同。
参数的顺序不同（当参数类型不同且数量相同）。
注意： 返回值类型不同不能作为函数重载的唯一依据。

2. 无效的重载示例（仅靠返回值类型区分）
int func(int a) {
    return a;
}

// 这是无效的重载，因为它仅改变了返回值类型
double func(int a) {
    return static_cast<double>(a);
}

错误解释：
编译器无法通过调用语句的返回值类型来区分调用哪个 func 函数。
这种情况下，编译器将报错，认为存在重复定义。

==============================================================================
=============================================================================

在C++中，模板是一种泛型编程的工具，允许你编写可以处理不同类型的代码。
模板分为两种主要类型：类模板和函数模板。以下是它们的详细解释和用法。

1. 类模板
类模板允许你创建一个可以操作不同数据类型的类，
而不必为每种类型单独定义一个类。

语法
```C++
template <typename T>
class ClassName {
public:
    T member;
    ClassName(T value) : member(value) {}
    void display() {
        std::cout << "Value: " << member << std::endl;
    }
};

#include <iostream>
#include <string>

// 定义一个类模板
template <typename T>
class Box {
private:
    T content;
public:
    Box(T content) : content(content) {}
    void showContent() {
        std::cout << "Content: " << content << std::endl;
    }
};

int main() {
    // 使用int类型实例化Box类
    Box<int> intBox(123);
    intBox.showContent();

    // 使用std::string类型实例化Box类
    Box<std::string> stringBox("Hello, Templates!");
    stringBox.showContent();

    return 0;
}

Content: 123
Content: Hello, Templates!
解释
template <typename T> 定义了一个类模板，其中 T 是一个类型参数，表示这个类可以操作的类型。
Box<T> 类定义了一个可以存储 T 类型数据的 Box，并有一个展示内容的成员函数 showContent()。
Box<int> 和 Box<std::string> 分别实例化了 Box 类，T 分别替换为 int 和 std::string 类型。

2. 函数模板
函数模板与类模板类似，它允许你编写一个可以处理不同数据类型的函数，而不必为每种类型单独定义一个函数。

语法
template <typename T>
T functionName(T a, T b) {
    return a + b;
}

#include <iostream>

// 定义一个函数模板
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    // 使用int类型实例化函数模板
    int result1 = add<int>(5, 10);
    std::cout << "Result1: " << result1 << std::endl;

    // 使用double类型实例化函数模板
    double result2 = add<double>(3.14, 2.71);
    std::cout << "Result2: " << result2 << std::endl;

    // 自动推导类型
    auto result3 = add(100, 200);  // 推导为int
    std::cout << "Result3: " << result3 << std::endl;

    return 0;
}

Result1: 15
Result2: 5.85
Result3: 300

解释

template <typename T> 定义了一个函数模板，其中 T 是一个类型参数，表示这个函数可以操作的类型。
add<T> 函数返回两个 T 类型参数的和。
可以在调用函数时显式指定类型，如 add<int>(5, 10)，也可以让编译器自动推导类型，如 add(100, 200)。
总结
    类模板 用于定义能够操作多种数据类型的类。
    函数模板 用于定义能够操作多种数据类型的函数。

```
=======================================================================
=========================================================================

- 编译过程: 
C++程序的编译过程可以分为四个主要步骤：预编译、编译、汇编和链接。这四个阶段各自执行不同的任务，最终将源代码转换为可执行的程序。以下是每个步骤的详细解释。

1. 预编译（Preprocessing）
预编译阶段处理源代码中的预处理指令，这些指令通常以 # 开头，例如 #include、#define 和 #ifdef 等。

宏展开: 预处理器将所有宏定义（#define）替换为其对应的值或代码块。
文件包含: 预处理器处理 #include 指令，将包含的头文件内容插入到相应的位置。
条件编译: 预处理器根据 #ifdef、#ifndef、#if、#else 和 #endif 等条件编译指令，决定是否保留某些代码段。
注释移除: 预处理器会移除所有的注释内容。
预处理后的文件通常以 .i 或 .ii 作为扩展名（对于C和C++代码）。

2. 编译（Compilation）
编译阶段将预处理后的代码转换为汇编代码。

语法分析: 编译器对预处理后的代码进行语法分析，检查代码的语法是否正确，并生成语法树（AST）。
语义分析: 编译器检查代码的语义，例如类型检查、变量声明和使用等。
代码优化: 编译器可能对代码进行一些优化，以提高程序的性能。
生成汇编代码: 最后，编译器将语法树转换为汇编代码，汇编代码是针对特定CPU架构的低级代码。
编译后的汇编代码文件通常以 .s 作为扩展名。

3. 汇编（Assembly）
汇编阶段将汇编代码转换为机器代码，也称为目标代码。

汇编器（Assembler）将汇编代码（.s 文件）翻译成机器指令，生成二进制的目标文件（object file）。
目标文件是机器可读的二进制文件，但它不是一个独立的可执行程序。目标文件通常以 .o 或 .obj 作为扩展名。
4. 链接（Linking）
链接阶段将一个或多个目标文件和库文件结合起来，生成最终的可执行文件。

符号解析: 链接器将所有目标文件中的符号进行解析，确保所有的函数调用和全局变量都能找到定义。
地址绑定: 链接器为每个目标文件中的符号分配内存地址，以便在程序运行时能够正确地访问它们。
库链接: 链接器会将静态库或动态库中的代码与目标文件链接在一起，以满足程序的依赖。
生成可执行文件: 最后，链接器生成一个可执行文件（例如，Linux上的 a.out 或 Windows上的 .exe 文件）。
整体流程总结
预编译（Preprocessing）: 处理预处理指令，生成预处理后的代码。
编译（Compilation）: 将预处理后的代码转换为汇编代码。
汇编（Assembly）: 将汇编代码转换为机器代码，生成目标文件。
链接（Linking）: 将多个目标文件和库文件链接在一起，生成最终的可执行文件。
通过这些步骤，源代码最终被转换为一个可以在目标机器上运行的程序。

==========================================================================
========================================================================

virtual 关键字 基类 以及 子类
编译器  生成虚函数表  虚函数指针数组

子类如果复写了基类的里面的虚函数的话
那么子类这个虚函数表也就是 这个虚函数数组当中 填的是的子类复写的那个函数的地址
这句话告诉我们虚函数表是在 编译期间产生的
经过汇编、链接 会生成一个可执行程序 , 其中有一个ELF格式的文件

虚函数表就在ELF文件里 .rodata(只读数据段)里面
这个段是只读的
这个段里面存的就是虚函数表

而 虚函数存在 .text代码段中

运行可执行程序, 此时你就要清楚C++的 内存分布
1. 堆
2. 栈
3. 全局静态区
4. 常量区(只读数据)
5. 代码区

虚函数表指针 和 对象的创建----存储位置一致  存在 堆区或者栈区
虚函数表存在 .rodata(只读数据段)里面
虚函数存在 .text代码段中

文件映射区并不在里面 而是在 虚拟内存区域里

接下来我们再创建这些类的对象的时候, 我们会在构造函数当中去生成这个虚函数表指针
虚函数表指针指向的地址就是 虚函数表具体的地址

一种是直接用子类指针接收对象, 找到对应的函数
Drived * d = new Derived

另一种用的最多的是 
使用基类指针, 去接受具体的对象, 根据对象来, 去找子类的这个虚函数表指针
在该虚函数表中找到对应的函数去处理
Base * b = new Derived

总结: 根据指针 或 引用 实际指向的对象, 来选择具体方法调用

注意: 虚函数表 和 虚函数指针 是一一对应的关系
假设 class C : public A, public B{};
A B 都有虚函数
那么 C里会有两个 虚函数表指针

class Base{};
sizeof(Base) = 1;

class Base1
{
public:
    virtual void foo()
    {
        std::cout << " Base1::foo()" << std::endl;
    }

    virtual void bar()
    {
        std::cout << " Base1::bar()" << std::endl;
    }
};

sizeof(Base1) = 8;


class Base2
{
public:
    virtual void baz()
    {
        std::cout << " Base2::baz()" << std::endl;
    }
};

class Drived1 : public Base1
{

};
sizeof(Drived1) = 8;


class Drived2 : public Base1
{
public:
    virtual void foo()
    {
        std::cout << Drived2::foo << std::endl;
    }

    virtual void baz()
    {
        std::cout << " Base2::baz()" << std::endl;
    }
};


class Drived3 : public Base1, public Base2
{
public:
    virtual void baz()
    {
        std::cout << " Drived3::bar()" << std::endl;
    }
};


========================================================================
========================================================================

动态联编==动态绑定==动态多态
动态绑定是怎么实现的?
动态绑定（Dynamic Binding），又称为晚绑定（Late Binding），在面向对象编程中指的是在运行时而不是编译时决定函数调用的具体实现。动态绑定通常用于实现多态性，特别是在基类指针或引用指向派生类对象时调用虚函数的场景。

动态绑定的实现原理
在C++中，动态绑定通过虚函数表（Virtual Table，vtable） 和 虚函数指针（Virtual Pointer，vptr） 机制来实现。

1. 虚函数表（vtable）
虚函数表 是编译器为每个含有虚函数的类生成的一个表格。这个表格包含了指向该类中虚函数的指针。
每个包含虚函数的类都有自己的虚函数表（vtable），而这个表在编译时生成。
虚函数表中存储了该类对象所对应的各个虚函数的地址。
2. 虚函数指针（vptr）
虚函数指针 是指向虚函数表的指针。每个对象都有一个隐含的指针（vptr），指向它所属类的虚函数表。
在构造对象时，编译器会自动将对象的vptr初始化为指向该对象所属类的虚函数表。
3. 动态绑定的实现过程
当调用对象的虚函数时，程序会首先通过vptr找到该对象的虚函数表vtable。
然后根据函数在类中的偏移量（通常通过函数名）从虚函数表中查找到对应的函数指针。
最后，通过这个函数指针进行函数调用。
```C++
#include <iostream>

class Base {
public:
    virtual void show() { // 虚函数
        std::cout << "Base class show function." << std::endl;
    }
    virtual ~Base() = default; // 虚析构函数
};

class Derived : public Base {
public:
    void show() override { // 重写虚函数
        std::cout << "Derived class show function." << std::endl;
    }
};

int main() {
    Base *b = new Derived(); // 基类指针指向派生类对象
    b->show(); // 动态绑定，调用Derived类的show函数

    delete b; // 调用虚析构函数，防止内存泄漏
    return 0;
}
```
执行过程分析
对象构造:

当 Derived 对象被创建时，它的 vptr 被初始化为指向 Derived 类的虚函数表。
Base 类的虚函数表中存储的是 Base::show 函数的地址，而 Derived 类的虚函数表中存储的是 Derived::show 函数的地址。
函数调用:

当 b->show() 被调用时，由于 show() 是一个虚函数，程序会通过 b 的 vptr 找到 Derived 类的虚函数表，然后查找到 Derived::show 的地址并进行调用。
动态绑定:

尽管 b 是一个 Base 类的指针，但由于动态绑定的机制，程序在运行时决定调用 Derived 类的 show 函数，而不是 Base 类的 show 函数。
===========================================================================

为什么基类析构函数要设置为虚函数
在C++中，如果你有一个多态类（即包含虚函数的类），那么基类的析构函数应该定义为虚函数。这是为了确保当通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数，从而防止资源泄漏和未定义行为的发生。

原因解释
1. 多态性和动态绑定
当你使用多态性时，基类指针或引用可以指向派生类对象。例如：

Base* ptr = new Derived();
在这种情况下，如果基类的析构函数不是虚函数，删除 ptr 会导致以下问题：

delete ptr; // 如果Base的析构函数不是虚函数
编译器在编译时根据指针的静态类型（即 Base*）决定调用哪个析构函数。如果基类的析构函数不是虚函数，编译器会调用 Base 类的析构函数，而不会调用 Derived 类的析构函数。
这样会导致 Derived 类中的资源（如动态分配的内存）不会被正确释放，造成资源泄漏或其他未定义行为。
2. 正确释放派生类资源
通过将基类的析构函数声明为虚函数，删除 ptr 时，编译器会在运行时通过虚函数表（vtable）找到派生类的析构函数并正确调用它。整个过程如下：

virtual ~Base() {
    // 基类析构函数
}

delete ptr; // 调用Derived的析构函数，然后调用Base的析构函数
当 delete ptr 被调用时，首先调用 Derived 类的析构函数，释放 Derived 类中分配的资源。
然后，自动调用 Base 类的析构函数，释放 Base 类中分配的资源。
3. 避免资源泄漏和未定义行为
如果不将基类析构函数设为虚函数，可能会发生以下情况：

资源泄漏: 派生类中的资源不会被正确释放。
未定义行为: 可能会导致程序崩溃或其他难以调试的错误。
示例代码
以下是一个示例，展示基类析构函数为虚函数和非虚函数时的区别：

#include <iostream>

class Base {
public:
    Base() { std::cout << "Base constructor" << std::endl; }
    virtual ~Base() { std::cout << "Base destructor" << std::endl; } // 虚析构函数
};

class Derived : public Base {
public:
    Derived() { std::cout << "Derived constructor" << std::endl; }
    ~Derived() { std::cout << "Derived destructor" << std::endl; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr; // 正确调用Derived和Base的析构函数
    return 0;
}
输出：

Base constructor
Derived constructor
Derived destructor
Base destructor
解释：

由于 Base 的析构函数是虚函数，调用 delete ptr 时，先调用 Derived 类的析构函数，再调用 Base 类的析构函数，确保资源正确释放。
如果 Base 类的析构函数不是虚函数，输出将变为：

Base constructor
Derived constructor
Base destructor
此时，Derived 类的析构函数不会被调用，导致派生类中的资源未被正确释放，可能引发资源泄漏或其他问题。

===============================================================================

虚函数表的创建时机(什么时候创建的) :   
            编译器发现类中包含virtual关键字修饰的函数,在类定义时创建虚函数表，在对象创建时初始化虚函数表指针。
            虚函数表的内容在编译器编译的时候已经生成 -- ELF文件里的 .rodata段
            虚函数表是一个存储类成员函数指针的数组


虚函数表指针的创建时机(什么时候创建的)

        类对象构造的时候, 在构造函数将虚函数表的地址赋值给对象vptr
        如果类没有构造函数, 则编译器为类生成默认构造函数, 从而为类对象初始化vptr

        继承下, 虚函数表指针复制过程:
                              调用基类构造函数的时候, 先将基类的虚函数表地址赋值给vptr
                              接着调用子类构造函数的时候,又将子类的虚函数表地址赋值给vptr


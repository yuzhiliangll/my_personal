1. poll函数
poll的机制与select类似，与select在本质上没有多大差别，使用方法也类似，
下面的是对于二者的对比：

内核对应文件描述符的检测也是以线性的方式进行轮询，根据描述符的状态进行处理
poll和select检测的文件描述符集合会在检测过程中频繁的进行用户区和内核区的拷贝，它的开销随着文件描述符数量的增加而线性增大，从而效率也会越来越低。
select检测的文件描述符个数上限是1024，poll没有最大文件描述符数量的限制
select可以跨平台使用，poll只能在Linux平台使用

poll函数的函数原型如下：
#include <poll.h>
// 每个委托poll检测的fd都对应这样一个结构体
struct pollfd {
    int   fd;         /* 委托内核检测的文件描述符 */
    short events;     /* 委托内核检测文件描述符的什么事件 */
    short revents;    /* 文件描述符实际发生的事件 -> 传出 */
};

struct pollfd myfd[100];
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

函数参数：

    fds: 这是一个struct pollfd类型的数组, 里边存储了待检测的文件描述符的信息，这个数组中有三个成员：

        fd：委托内核检测的文件描述符
        events：委托内核检测的fd事件（输入、输出、错误），每一个事件有多个取值
        revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果

    nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数1数组的元素总个数）

    timeout: 指定poll函数的阻塞时长

        -1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞
        0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回
        大于0：阻塞指定的毫秒（ms）数之后，解除阻塞

函数返回值：

失败： 返回-1
成功：返回一个大于0的整数，表示检测的集合中已就绪的文件描述符的总个数

==========================================================================

客户端不需要使用 IO 多路转接进行处理, 因为客户端和服务器端的对应关系是 1:N 也就是说客户端是比较专一的, 只能和一个连接成功的服务器通信

虽然使用 select 这种IO 多路转接技术可以降低系统开销, 提高程序效率, 但是他也有局限性

1. 待检测集合(第2、3、4个参数)需要频繁的在用户区和内核区进行数据的拷贝,效率低
2. 内核对于select 传递进来的待检测集合的检测方式是线性的
    如果集合内的文件描述符数量很大, 那么效率就会很低
3. select 传递进来的待检测集合的大小是有限制的, 也就是第3个参数 nfds 的值, 这个值默认是 1024, 如果超过了这个值, 那么就会报错
    所以 select 这种IO 多路转接技术比较适合于文件描述符数量比较少的情况

==========================================================================

select 和 poll 是 UNIX 系统中常用的两种 IO 多路复用机制，用于监视多个文件描述符的状态，判断哪些文件描述符可以进行读、写操作，或者是否有异常情况发生。以下是对它们特点的总结：

select 的特点
接口简单：

select 使用三个文件描述符集合（读、写、异常）来监视多个文件描述符的状态。每个集合是一个位图（bitmap），每个位表示一个文件描述符的状态。
支持的文件描述符数量有限：

select 的文件描述符数量受限于 FD_SETSIZE（通常为 1024），无法监视超过此数量的文件描述符。
文件描述符需要重新设置：

每次调用 select 之后，文件描述符集合会被修改，需要在下一次调用前重新设置集合。
效率低下：

select 采用线性扫描的方式来检查每个文件描述符的状态。当监视的文件描述符数量增多时，性能会明显下降，尤其是在高并发场景下。
兼容性好：

select 是最早实现的 IO 多路复用机制，几乎所有的 UNIX-like 系统都支持，因此兼容性非常好。
poll 的特点
支持更多的文件描述符：

poll 使用 pollfd 结构体数组来监视文件描述符，文件描述符的数量仅受限于系统的最大文件描述符数量，不像 select 那样有固定的上限。
文件描述符不需要重新设置：

与 select 不同，poll 每次调用后不会修改传入的 pollfd 结构体数组，因此不需要在每次调用前重新设置。
依旧使用线性扫描：

与 select 一样，poll 也是通过线性扫描文件描述符数组来检查状态，因此在处理大量文件描述符时，性能仍然较低。
支持更多的事件类型：

poll 比 select 支持更多的事件类型，如普通数据、带外数据、挂起操作等，提供了更丰富的事件监控功能。
不区分读、写、异常集合：

poll 通过 pollfd 结构体中的 events 和 revents 字段来指定和获取文件描述符的状态，而不是使用三个独立的集合。
select 和 poll 的比较
可扩展性：

poll 能够处理更多的文件描述符，扩展性优于 select。
性能：

两者在大量文件描述符的情况下都表现不佳，因为都使用线性扫描，但 poll 能处理的文件描述符更多。
兼容性：

select 兼容性更好，几乎所有 UNIX-like 系统都支持，但 poll 的支持也相当广泛。
代码复杂度：

select 使用位图表示文件描述符状态，可能导致代码操作上稍微复杂；poll 使用结构体数组，操作相对简单直观。
总结
如果兼容性和简单性是首要考虑，可以选择 select。
如果需要处理更多文件描述符，或事件类型更复杂，可以选择 poll。
对于更高效的 IO 多路复用，可以考虑 epoll（Linux）或 kqueue（BSD）等更现代的机制，它们克服了 select 和 poll 的性能限制，适用于高并发场景。



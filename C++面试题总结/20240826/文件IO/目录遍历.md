众所周知，Linux的目录是一个树状结构，了解数据结构的小伙伴都明白，遍历一棵树最简单的方式是递归。在我们已经掌握了递归的使用方法之后，遍历树状目录也不是一件难事儿。

Linux给我们提供了相关的目录遍历的函数，分别为：opendir(), readdir(), closedir()。目录的操作方式和标准C库提供的文件操作步骤是类似的。下面来依次介绍一下这几个函数。

1. 目录三剑客
1.1 opendir
在目录操作之前必须要先通过 opendir() 函数打开这个目录，函数原型如下：

```C

#include <sys/types.h>
#include <dirent.h>
// 打开目录
DIR *opendir(const char *name);
参数: name -> 要打开的目录的名字
返回值: DIR*, 结构体类型指针。打开成功返回目录的实例，打开失败返回 NULL
1.2 readdir
目录打开之后，就可以通过 readdir() 函数遍历目录中的文件信息了。每调用一次这个函数就可以得到目录中的一个文件信息，当目录中的文件信息被全部遍历完毕会得到一个空对象。先来看一下这个函数原型：

C

// 读目录
#include <dirent.h>
struct dirent *readdir(DIR *dirp);
参数：dirp -> opendir() 函数的返回值
返回值：函数调用成功，返回读到的文件的信息, 目录文件被读完了或者函数调用失败返回 NULL
函数返回值 struct dirent 结构体原型如下:

C

struct dirent {
    ino_t          d_ino;       /* 文件对应的inode编号, 定位文件存储在磁盘的那个数据块上 */
    off_t          d_off;       /* 文件在当前目录中的偏移量 */
    unsigned short d_reclen;    /* 文件名字的实际长度 */
    unsigned char  d_type;      /* 文件的类型, linux中有7中文件类型 */
    char           d_name[256]; /* 文件的名字 */
};
关于结构体中的文件类型d_type，可使用的宏值如下：

DT_BLK：块设备文件
DT_CHR：字符设备文件
DT_DIR：目录文件
DT_FIFO ：管道文件
DT_LNK：软连接文件
DT_REG ：普通文件
DT_SOCK：本地套接字文件
DT_UNKNOWN：无法识别的文件类型
那么，如何通过 readdir() 函数遍历某一个目录中的文件呢？

C

// 打开目录
DIR* dir = opendir("/home/test");
struct dirent* ptr = NULL;
// 遍历目录
while( (ptr=readdir(dir)) != NULL)
{
    .......
}
1.3 closedir
目录操作完毕之后, 需要通过 closedir()关闭通过opendir()得到的实例，释放资源。函数原型如下：

C
1
2
// 关闭目录, 参数是 opendir() 的返回值
int closedir(DIR *dirp);
参数：dirp-> opendir() 函数的返回值
返回值: 目录关闭成功返回0, 失败返回 -1
2.遍历目录
2.1 遍历单层目录
如果只遍历单层目录是不需要递归的，按照上边介绍的函数的使用方法，依次继续调用即可。假设我们需要得到某个指定目录下 mp3 格式文件的个数，示例代码如下：

C

// filenum.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>

int main(int argc, char* argv[])
{
    // 1. 打开目录
    DIR* dir = opendir(argv[1]);
    if(dir == NULL)
    {
        perror("opendir");
        return -1;
    }

    // 2. 遍历当前目录中的文件
    int count = 0;
    while(1)
    {
        struct dirent* ptr = readdir(dir);
        if(ptr == NULL)
        {
            printf("目录读完了...\n");
            break;
        }
        // 读到了一个文件
        // 判断文件类型
        if(ptr->d_type == DT_REG)
        {
            char* p = strstr(ptr->d_name, ".mp3");//strstr() 是 C 标准库中的一个函数，用于在字符串中查找子字符串的首次出现。如果找到了子字符串，就返回一个指向它的指针，否则返回 NULL。
            if(p != NULL && *(p+4) == '\0')//这一步是在进一步检查 .mp3 是否位于文件名的末尾,也就是说，这里检查的是文件名是否以 .mp3 结尾，而不是 .mp3 后面还有其他字符
            {
                count++;
                printf("file %d: %s\n", count, ptr->d_name);
            }
        }
    }

    printf("%s目录中mp3文件的个数: %d\n", argv[1], count);

    // 关闭目录
    closedir(dir);

    return 0;
}
编译名执行程序

SHELL

$ gcc filenum.c
# 读当前目录中mp3文件个数
$ ./a.out .
file 1: 1.mp3
目录读完了...
.目录中mp3文件的个数: 1

# 读 ./sub 目录中mp3文件个数
$ ./a.out ./sub/
file 1: 3.mp3
file 2: 1.mp3
file 3: 5.mp3
file 4: 4.mp3
file 5: 2.mp3
目录读完了...
./sub/目录中mp3文件的个数: 5
```
============================================================

strstr 函数是 C 标准库 <string.h> 中的一个函数，用于在一个字符串中查找子字符串的首次出现。它的作用是找到子字符串在源字符串中的位置，并返回一个指向这个位置的指针。
如果子字符串不在源字符串中，则返回 NULL。
```C
char *strstr(const char *haystack, const char *needle);
```
参数说明
haystack：指向要搜索的源字符串（在这个字符串中查找子字符串）。
needle：指向要查找的子字符串。
返回值
如果找到了子字符串，则返回指向它在源字符串中首次出现位置的指针。
如果没有找到子字符串，则返回 NULL。
```C++
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello, world!";
    char *subStr = "world";
    
    char *result = strstr(str, subStr);
    
    if (result) {
        printf("Found substring '%s' at position: %ld\n", subStr, result - str);
    } else {
        printf("Substring not found.\n");
    }
    
    return 0;
}
在上述示例中，strstr(str, subStr) 搜索 "world" 在字符串 "Hello, world!" 中的首次出现。
如果找到，result 会指向 "world" 在 "Hello, world!" 中的位置，result - str 计算出子字符串在源字符串中的位置（以零为基准的索引）。
输出将是：Found substring 'world' at position: 7。
strstr 的用途
strstr 常用于以下场景：

在字符串中查找某个特定的模式（如查找文件扩展名、查找URL中的特定部分等）。
判断某个字符串是否包含特定的子字符串。
在文本处理、解析、数据提取等操作中，定位关键字或标记。

```

===================================================================

2.2 遍历多层目录
Linux 的目录是树状结构，遍历每层目录的方式都是一样的，也就是说最简单的遍历方式是递归。程序的重点就是确定递归结束的条件：遍历的文件如果不是目录类型就结束递归。

示例代码如下：

```C

// filenum.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>

int getMp3Num(const char* path)
{
    // 1. 打开目录
    DIR* dir = opendir(path);
    if(dir == NULL)
    {
        perror("opendir");
        return 0;
    }
    // 2. 遍历当前目录
    struct dirent* ptr = NULL;
    int count = 0;
    while((ptr = readdir(dir)) != NULL)
    {
        // 如果是目录 . .. 跳过不处理
        if(strcmp(ptr->d_name, ".")==0 ||
           strcmp(ptr->d_name, "..") == 0)
        {
            continue;
        }
        // 假设读到的当前文件是目录
        if(ptr->d_type == DT_DIR)
        {
            // 目录
            char newPath[1024];
            // 拼接新路径
            // 使用 sprintf 函数将路径和文件名格式化成一个完整的文件路径，并将结果存储在 newPath 变量中。
            sprintf(newPath, "%s/%s", path, ptr->d_name);

            // 读当前目录的子目录
            count += getMp3Num(newPath);
        }
        else if(ptr->d_type == DT_REG)
        {
            // 普通文件
            char* p = strstr(ptr->d_name, ".mp3");
            // 判断文件后缀是不是 .mp3
            if(p != NULL && *(p+4) == '\0')
            {
                count++;
                printf("%s/%s\n", path, ptr->d_name);
            }
        }
    }

    closedir(dir);
    return count;
}

int main(int argc, char* argv[])
{
    // ./a.out path
    if(argc < 2)
    {
        printf("./a.out path\n");
        return 0;
    }

    int num = getMp3Num(argv[1]);
    printf("%s 目录中mp3文件个数: %d\n", argv[1], num);

    return 0;
}
编译并运行程序：

SHELL

$ gcc filenum.c
# 查看 abc 目录中mp3 文件个数
$ ./a.out abc
abc/sub/3.mp3
abc/sub/1.mp3
abc/sub/5.mp3
abc/sub/4.mp3
abc/sub/2.mp3
abc/sub/music/test2.mp3
abc/sub/music/test3.mp3
abc/sub/music/test1.mp3
abc/hello.mp3
abc 目录中mp3文件个数: 9
3. scandir函数
除了使用上边介绍的目录三剑客遍历目录，也可以使用scandir()函数进行目录的遍历（只遍历指定目录，不进入到子目录中进行递归遍历），它的参数并不简单，涉及到三级指针和回调函数的使用。

其函数原型如下：

C

// 头文件
#include <dirent.h> 
int scandir(const char *dirp, struct dirent ***namelist,
              int (*filter)(const struct dirent *),
              int (*compar)(const struct dirent **, const struct dirent **));
int alphasort(const struct dirent **a, const struct dirent **b);
int versionsort(const struct dirent **a, const struct dirent **b);
参数:
dirp: 需要遍历的目录的名字
namelist: 三级指针, 传出参数, 需要在指向的地址中存储遍历目录得到的所有文件的信息
在函数内部会给这个指针指向的地址分配内存，要注意在程序中释放内存
filter: 函数指针, 指针指向的函数就是回调函数, 需要在自定义函数中指定如果过滤目录中的文件
如果不对目录中的文件进行过滤, 该函数指针指定为NULL即可
如果自己指定过滤函数, 满足条件要返回1, 否则返回 0
compar: 函数指针, 对过滤得到的文件进行排序, 可以使用提供的两种排序方式:
alphasort: 根据文件名进行排序
versionsort: 根据版本进行排序
返回值: 函数执行成功返回找到的匹配成功的文件的个数，如果失败返回-1。
3.1 文件过滤
scandir() 可以让使用者自定义文件的过滤方式, 然后将过滤函数的地址传递给 scandir() 的第三个参数，我们可以得知过滤函数的原型是这样的：

C
1
2
// 函数的参数就是遍历的目录中的子文件对应的结构体
int (*filter)(const struct dirent *);
基于这个函数指针定义的函数就可以称之为回调函数, 这个函数不是由程序猿调用, 而是通过 scandir() 调用，因此这个函数的实参也是由 scandir() 函数提供的，作为回调函数的编写人员，只需要搞明白这个参数的含义是什么，然后在函数体中直接使用即可。

假设还是判断目录中某一个文件是否为Mp3格式, 函数实现如下:

C

int isMp3(const struct dirent *ptr)
{
    if(ptr->d_type == DT_REG)
    {
        char* p = strstr(ptr->d_name, ".mp3");
        if(p != NULL && *(p+4) == '\0')
        {
            return 1;
        }
    }
    return 0;
}
3.2 遍历目录
了解了 scandir() 函数的使用之后, 下边写一个程序, 来搜索指定目录下的 mp3格式文件个数和文件名, 代码如下:

C

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>

// 文件过滤函数
int isMp3(const struct dirent *ptr)
{
    if(ptr->d_type == DT_REG)
    {
        char* p = strstr(ptr->d_name, ".mp3");
        if(p != NULL && *(p+4) == '\0')
        {
            return 1;
        }
    }
    return 0;
}

int main(int argc, char* argv[])
{
    if(argc < 2)
    {
        printf("./a.out path\n");
        return 0;
    }
    struct dirent **namelist = NULL;
    int num = scandir(argv[1], &namelist, isMp3, alphasort);
    for(int i=0; i<num; ++i)
    {
        printf("file %d: %s\n", i, namelist[i]->d_name);
        free(namelist[i]);
    }
    free(namelist);
    return 0;
}
最后再解析一下 scandir() 的第二个参数，传递的是一个二级指针的地址:

C
1
2
struct dirent **namelist = NULL;
int num = scandir(argv[1], &namelist, isMp3, alphasort);
那么在这个 namelist 中存储的什么类型的数据呢？也就是 struct dirent **namelist 指向的什么类型的数据?

答案: 指向的是一个指针数组 struct dirent *namelist[]

数组元素的个数就是遍历的目录中的文件个数
数组的每个元素都是指针类型: struct dirent *, 指针指向的地址是有 scandir() 函数分配的, 因此在使用完毕之后需要释放内存




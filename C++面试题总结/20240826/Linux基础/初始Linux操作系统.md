Linux 的内核主要由 5 个子系统组成：
进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。
下面将依次讲解这 5 个子系统。

进程调度 SCHED

进程调度指的是系统对进程的多种状态之间转换的策略。Linux 下的进程调度有 3 种策略：SCHED_OTHER、SCHED_FIFO 和 SCHED_RR。

SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。
SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略
SCHED_RR：实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。
内存管理 MMU

内存管理是多个进程间的内存共享策略。在Linux中，内存管理主要说的是虚拟内存。
虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。
每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。
虚拟文件系统 VFS

在 Linux 下支持多种文件系统，如 ext、ext2、minix、umsdos、msdos、vfat、ntfs、proc、smb、ncp、iso9660、sysv、hpfs、affs 等。
目前 Linux 下最常用的文件格式是 ext2 和 ext3。
网络接口

Linux 是在 Internet 飞速发展的时期成长起来的，所以 Linux 支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux 支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。

进程间通信

Linux 操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux 的进程间通信是从 UNIX 系统继承过来的。Linux 下的进程间的通信方式主要有管道、信号、消息队列、共享内存和套接字等方法。

===================================================================


ext2 和 ext3 是两种常见的 Linux 文件系统，它们都源自于 UNIX 文件系统，但在功能和特性上有所不同。以下是它们的详细比较和总结。

ext2 文件系统
诞生时间：

ext2 是第二代扩展文件系统（Second Extended File System），于 1993 年发布。
无日志功能：

ext2 文件系统没有日志功能。这意味着在系统意外崩溃或断电时，文件系统可能会变得不一致，需要运行 fsck 工具来修复文件系统。
性能：

由于没有日志功能，ext2 在写操作时的性能通常优于具有日志功能的文件系统（如 ext3），特别是在不需要数据完整性的场景下。
使用场景：

ext2 文件系统适用于需要高写入性能且对数据完整性要求不高的场景，例如嵌入式设备或只读文件系统。
文件系统大小：

ext2 支持的最大文件大小为 2TB，支持的最大文件系统大小为 32TB。
碎片问题：

ext2 在长时间使用后可能会产生碎片，但由于其设计较为简洁，碎片问题相对较少。
ext3 文件系统
诞生时间：

ext3 是第三代扩展文件系统（Third Extended File System），于 2001 年发布，是 ext2 的继任者。
日志功能：

ext3 最显著的改进是增加了日志功能（journaling），它可以记录文件系统的元数据和部分数据的变更日志。在系统崩溃后，可以快速恢复文件系统的一致性，减少了数据丢失的风险。
日志模式：

ext3 提供了三种日志模式：
Writeback：仅记录元数据的日志，可能会丢失部分数据，但恢复速度最快。
Ordered：默认模式，记录元数据日志，并确保数据在元数据之前被写入磁盘。
Journal：记录元数据和数据的日志，确保数据完整性，但性能相对较低。
向后兼容：

ext3 向后兼容 ext2，可以直接将 ext2 文件系统升级为 ext3，只需添加日志功能即可。
性能：

由于增加了日志功能，ext3 的写入性能通常比 ext2 略差，但在数据安全性和恢复能力上更为出色。
使用场景：

ext3 适用于需要数据安全性和一致性的场景，例如服务器和工作站。
文件系统大小：

与 ext2 相似，ext3 也支持最大 2TB 的文件大小和 32TB 的文件系统大小。
碎片问题：

ext3 继承了 ext2 的架构，碎片问题相对较少，但其日志功能可能会在某些情况下增加碎片的概率。
总结
ext2：没有日志功能，适合对数据完整性要求不高且需要高写入性能的场景，如嵌入式设备。
ext3：具有日志功能，适合对数据完整性要求较高的场景，提供了更好的数据恢复能力和一致性。
如果对性能要求高且数据丢失风险可以接受，可以选择 ext2；如果需要数据安全性和系统稳定性，ext3 是更好的选择。

=============================================================

2. Linux 目录
与 Windows 下的文件组织结构不同，Linux 不使用磁盘分区符号来访问文件系统，而是将整个文件系统表示成树状的结构，Linux 系统每增加一个文件系统都会将其加入到这个树中。
操作系统文件结构的开始，只有一个单独的顶级目录结构，叫做根目录。所有一切都从“根”开始，用“/”代表，并且延伸到子目录。Linux 则通过“挂接”的方式把所有分区都放置在“根”下各个目录里。一个 Linux 系统的文件结构如下图所示。

2.1 Linux目录结构

在linux中根目录的子目录结构相对是固定的(名字固定), 不同的目录功能是也是固定的

bin: binary, 二进制文件目录, 存储了可执行程序, 今天要将的命令对应的可执行程序都在这个目录中

sbin: super binary, root用户使用的一些二进制可执行程序

etc: 配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中

lib: library, 存储了一些动态库和静态库，给系统或者安装的软件使用

media: 挂载目录, 挂载外部设备，比如: 光驱, 扫描仪

mnt: 临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下

proc: 内存使用的一个映射目录, 给操作系统使用的

tmp: 临时目录, 存放临时数据, 重启电脑数据就被自动删除了

boot: 存储了开机相关的设置

home: 存储了普通用户的家目录，家目录名和用户名相同

root: root用户的家目录

dev: device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标

lost+found: 一般时候是空的, 电脑异常关闭/崩溃时用来存储这些无家可归的文件, 用于用户系统恢复

opt: 第三方软件的安装目录

var: 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件

usr: unix system resource, 系统的资源目录

    /usr/bin: 可执行的二进制应用程序

    /usr/games: 游戏目录

    /usr/include: 包含的标准头文件目录

    /usr/local: 和opt目录作用相同, 安装第三方软件

对于用户自己的文件, 一般都是存放到自己的家目录中, 也就是 /home/用户名里边, 通过指定的相应的路径就可以找到这个文件了。关于路径的指定的有两种方式：相对路径和绝对路径。

=============================================================

# 这是在root用户的家目录中, 并且展示了家目录中的子目录的从属关系
[root@VM-8-14-centos ~]# tree
.
|-- ace
|   `-- brother
|       `-- finally
|           `-- die.txt
`-- luffy
    `-- get
        `-- onepiece
            `-- haha.txt

2.2 相对路径
相对路径：相对路径就是相对于当前文件的路径。在Linux中有两个表示路径的特殊符号:

./：代表目前所在的目录，也可以使用 .表示。

../：代表当前目录的上一层目录，也可以使用 ..表示。

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用相对路径

[root@VM-8-14-centos ~]# cd luffy/get/onepiece/

接下来研究一下相对路径的优缺点:

优点: 简洁, 目录相对较短, 书写方便
缺点: 变更工作目录之后, 使用相同的相对路径就找不到原来的文件了


2.3 绝对路径
绝对路径：从系统磁盘起始节点开始描述的路径。

Linux：起始节点为根目录，比如： /root/luffy/get/onepiece

Windows: 起始节点为某个磁盘的盘符，比如：f:\\root\\luffy\\get\\onepiece

以上边的目录为例, 从当前root家目录 /root, 进入到 onepiece目录使用绝对路径
[root@VM-8-14-centos ~]# cd /root/luffy/get/onepiece/

接下来研究一下绝对路径的优缺点:

优点: 不受工作目录的影响, 在操作系统的任意位置都可以通过绝对路径访问到对应的文件
缺点: 书写麻烦, 目录相对较长


3. 命令解析器
在Linux中需要通过终端执行对应的命令来完成某些操作, 那么这些命令是如何被执行的呢?

这些命令都是通过命令解析器解析完成并执行的, 如果用户在终端输入是正确的内部指令, 命令解析器就执行这个命令, 如果不是正确的指令, 则提示命令无法解析。

下图是Windows是命令行窗口，平台虽然不同但是命令解析器的工作原理是相同的。


3.1 工作原理
命令解析器在Linux操作系统中就是一个进程(运行的应用程序), 它的名字叫做bash通常我们更习惯将其称之为shell (即: sh)。他们之间的渊源是这样的，在Unix操作系统诞生之后一个叫伯恩(Bourne )的人为其编写了命令解析器取名为shell, Linux操作系统诞生之后伯恩再次改写了shell (sh), 将其称之为bash (Bourne Again SHell), bash 就是 sh 的增强版本。

在Linux操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用sh。当用户打开一个终端窗口，并输入相关指令， 按回车键， 这时候命令解析器就开始工作了， 具体步骤如下：

在Linux中有一个叫做PATH的环境变量, 里边存储了一些系统目录 (windows也有, 叫 Path)

SHELL
# 通过 echo 命令可以查看环境变量 PATH 中的值, 在shell中变量名前加 $ 就是取值
[root@VM-8-14-centos ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

命令解析器需要依次搜索 PATH中的各个目录, 检查这些目录中是否有用户输入的指令

如果找到了, 执行该目录下的可执行程序, 用户输入的命令就被执行完毕了

如果没有找到, 继续搜索其他目录, 最后还是没有找到, 会提示命令找不到, 因此无法被执行

SHELL
[root@VM-8-14-centos ~]# asdjflksd
-bash: asdjflksd: command not found

3.2 命令提示行
在Linux终端中, 输入要执行的指令之前会有想用的命令提示, 我们将其称之为命令提示行, 例如:

SHELL
[root@VM-8-14-centos ~/luffy/get/onepiece]#
[robin@VM-8-14-centos ~/luffy/get/onepiece]$ 

root : 当前登录的用户的用户名

@: at -> 在

VM-8-14-centos: 主机名, 在安装这个linux操作系统的时候手动指定, 可以修改

~: 当前用户的家目录
    在linux中有很多用户, 每个用户都用一个属于自己的目录, 这个目录称之为家目录
    普通用户家目录/home/用户名, root用户家目录 /root

~/luffy/get/onepiece: 当前用户所在的工作目录, 也可以使用 pwd命令查看

    #: 代表当前用户是root用户
    $: 当前用户是普通用户, 也就是说例子中的 robin是一个普通用户


3.3 命令行快捷键
我们在命令行输入一些指令的时候, 经常需要移动光标, 或者删除一些字符, 对应的一些快捷键操作如下表:

快捷键	                功能	            备注
Tab	                命令自动补齐	    在终端中输入 某个命令的前一个或若干个字符, 再按Tab键
Ctrl+p	        显示输入的上一个历史命令	从输入的最后一个命令往前倒, 也可以使用 ↑键
Ctrl+n	        显示输入的下一个历史命令	也可以使用 ↓键
Ctrl+a	            光标移动命命令行首	    也可以使用 Home键
Ctrl+e	            光标移动命命令行尾	    也可以使用 End键
Ctrl+u	            删除光标前的部分字符串	    无
Ctrl+k	            删除光标后的部分字符串	    无
→	                光标向右移动一个字符	    无
←	                光标向右移动一个字符	    无
Backspace/Delete	删除光标前/后的一个字符	    无




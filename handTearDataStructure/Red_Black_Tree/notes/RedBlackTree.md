#### RedBlackTree

前提: 二叉搜索树(左 < 根 < 右)

红黑树（Red-Black Tree）是一种自平衡二叉搜索树（BST），其特点是在树的每个节点上增加了颜色属性，以保持树的平衡。
红黑树的平衡性相较于AVL树略弱，但由于其旋转操作次数较少，
通常在插入和删除操作频繁的应用中更高效。

红黑树的性质：

每个节点是红色或黑色：节点的颜色是红色或黑色，这是红黑树的基本性质之一。

根节点是黑色：红黑树的根节点始终为黑色。

每个叶子节点（NULL节点）是黑色：所有的叶子节点，即树的外部节点，都是黑色的。通常在实现红黑树时，NULL节点是隐式的，可以被认为是黑色的虚拟节点。

红色节点的子节点必须是黑色：也就是说，红色节点不能有红色的子节点。红黑树中不存在两个相邻的红色节点（父节点和子节点不能同时为红色）。

从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点：这保证了红黑树的平衡性。每条从根到叶子的路径上必须有相同数量的黑色节点。

操作与调整：

插入：插入新节点后，红黑树可能会失去平衡。通过重新着色和旋转来恢复平衡。
删除：删除节点后，同样需要通过重新着色和旋转来恢复树的平衡。

旋转操作：
旋转操作和AVL树类似，用来保持树的平衡。主要有以下几种旋转：

左旋：用于修复右子树过高的情况。
右旋：用于修复左子树过高的情况。

红黑树的应用：
红黑树广泛应用于实现各种集合和关联数组的底层数据结构，
如C++中的std::map和std::set，以及Java中的TreeMap和TreeSet。


===================================================================

红黑树的插入操作相对复杂，因为需要在插入后保持红黑树的性质不被破坏。以下是红黑树插入的基本步骤和处理方式：

插入步骤：
按照二叉搜索树的规则插入新节点：

将新节点插入到适当的位置，使得二叉搜索树的性质（左 < 根 < 右）保持不变。
新插入的节点被初始化为红色。
调整树的平衡性：

插入新节点后，可能会破坏红黑树的性质，特别是如果新插入的节点的父节点也是红色的情况下。
通过“重新着色”和“旋转”操作来恢复红黑树的平衡。
调整方式：
假设新插入的节点为 z，它的父节点为 p(z)，祖父节点为 g(z)，叔叔节点为 u(z)。

情况1：插入节点是根节点
如果新节点 z 是根节点，将其颜色改为黑色，满足红黑树的性质。

情况2：父节点是黑色
如果 p(z) 是黑色，树仍然平衡，不需要进一步操作。

情况3：父节点是红色，叔叔节点也是红色
如果 p(z) 和 u(z) 都是红色，将 p(z) 和 u(z) 设为黑色，将 g(z) 设为红色。然后将 z 移动到 g(z)，并重复调整过程。

情况4：父节点是红色，叔叔节点是黑色或不存在，且新节点是父节点的右子节点
这种情况下，需要进行 左旋 操作。将 p(z) 设为 g(z) 的左子节点，然后进行左旋。此时 p(z) 和 z 交换角色，变成了父节点是左子节点的情况。

情况5：父节点是红色，叔叔节点是黑色或不存在，且新节点是父节点的左子节点
此时，需要进行 右旋 操作。将 p(z) 设为黑色，g(z) 设为红色，然后对 g(z) 进行右旋。





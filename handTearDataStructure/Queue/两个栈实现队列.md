队列的操作
push（入队）操作：

将元素压入栈1（stack1）。
pop（出队）操作：

如果栈2（stack2）为空，将栈1（stack1）中的所有元素逐个弹出并压入栈2（stack2）。
从栈2（stack2）中弹出元素。
peek（获取队头元素）操作：

如果栈2（stack2）为空，将栈1（stack1）中的所有元素逐个弹出并压入栈2（stack2）。
返回栈2（stack2）的栈顶元素。
示例
假设队列初始为空，stack1 和 stack2 也都是空的。我们将依次执行入队和出队操作来说明逻辑。

1. 入队操作 push(x)
操作：将元素 x 入队。

逻辑：

直接将 x 压入 stack1。
示例：

入队 10：

stack1: [10]
stack2: []

入队 20：

stack1: [10, 20]
stack2: []

入队 30：

stack1: [10, 20, 30]
stack2: []

2. 出队操作 pop()
操作：将队列头部元素出队。

逻辑：

如果 stack2 为空，将 stack1 中的所有元素逐个弹出并压入 stack2。
从 stack2 中弹出元素。
示例：

步骤 1：stack2 为空，将 stack1 中的元素移动到 stack2。

stack1: []
stack2: [30, 20, 10]

步骤 2：从 stack2 中弹出栈顶元素（队列头部元素）。

出队元素 10。

stack1: []
stack2: [30, 20]

出队 20：

stack1: []
stack2: [30]

出队 30：

stack1: []
stack2: []

3. 获取队头元素 peek()
操作：获取队列头部元素而不移除它。

逻辑：

如果 stack2 为空，将 stack1 中的所有元素逐个弹出并压入 stack2。
返回 stack2 的栈顶元素。
示例：

假设我们再次入队元素 40 和 50。

stack1: [40, 50]
stack2: []

步骤 1：stack2 为空，将 stack1 中的元素移动到 stack2。

stack1: []
stack2: [50, 40]

步骤 2：返回 stack2 的栈顶元素（40），但不弹出它。

stack1: []
stack2: [50, 40]

总结
push(x)：将元素 x 压入 stack1。
pop()：如果 stack2 为空，将 stack1 中的所有元素转移到 stack2，然后从 stack2 弹出栈顶元素。
peek()：如果 stack2 为空，将 stack1 中的所有元素转移到 stack2，然后返回 stack2 的栈顶元素。

==============================================================================

当 stack1 和 stack2 都不是空的情况下，我们需要对 pop 和 peek 操作的逻辑进行处理。以下是详细说明以及多种情况的处理方法：

操作逻辑
push（入队）：

无论 stack1 和 stack2 的状态如何，push 操作都会直接将元素压入 stack1。此操作不会涉及 stack2。
pop（出队）：

如果 stack2 非空：直接从 stack2 中弹出栈顶元素。
如果 stack2 为空：将 stack1 中的所有元素逐个弹出并压入 stack2，然后从 stack2 中弹出栈顶元素。
这种情况通常发生在队列需要从 stack2 中弹出元素时，但 stack2 当前为空。
peek（获取队头元素）：

如果 stack2 非空：直接返回 stack2 的栈顶元素。
如果 stack2 为空：将 stack1 中的所有元素逐个弹出并压入 stack2，然后返回 stack2 的栈顶元素。
多种情况处理
stack1 和 stack2 都不为空：

入队操作：

直接将元素压入 stack1。stack2 不受影响。
出队操作：

如果 stack2 非空，直接从 stack2 中弹出元素。
如果 stack2 为空，使用 stack1 的元素填充 stack2，然后从 stack2 中弹出元素。这种情况下，stack2 会从 stack1 中转移元素，并弹出相应的元素。
获取队头元素操作：

如果 stack2 非空，直接返回 stack2 的栈顶元素。
如果 stack2 为空，使用 stack1 的元素填充 stack2，然后返回 stack2 的栈顶元素。
示例
让我们通过具体的示例来说明这些操作。

初始状态
stack1: [30, 20, 10] （最近入队的元素在栈底）
stack2: [40, 50] （栈顶是队列头元素）
操作 1: peek()
步骤：

stack2 非空，因此直接返回 stack2 的栈顶元素，即 40。
结果：

stack1: [30, 20, 10]
stack2: [40, 50]
返回值：40
操作 2: pop()
步骤：

stack2 非空，因此直接从 stack2 中弹出栈顶元素，即 40。
结果：

stack1: [30, 20, 10]
stack2: [50]
被弹出的元素：40
操作 3: push(60)
步骤：

stack1 和 stack2 的状态与 push 操作无关。直接将 60 压入 stack1。
结果：

stack1: [30, 20, 10, 60]
stack2: [50]
操作 4: peek()
步骤：

stack2 非空，因此直接返回 stack2 的栈顶元素，即 50。
结果：

stack1: [30, 20, 10, 60]
stack2: [50]
返回值：50
操作 5: pop()
步骤：

stack2 非空，因此直接从 stack2 中弹出栈顶元素，即 50。
结果：

stack1: [30, 20, 10, 60]
stack2: []
被弹出的元素：50
操作 6: pop()
步骤：

stack2 为空，因此将 stack1 中的所有元素逐个弹出并压入 stack2：
stack1 弹出 60，压入 stack2。
stack1 弹出 10，压入 stack2。
stack1 弹出 20，压入 stack2。
stack1 弹出 30，压入 stack2。
然后从 stack2 中弹出栈顶元素，即 30。
结果：

stack1: []
stack2: [60, 10, 20]
被弹出的元素：30
总结
push(x)：将元素 x 压入 stack1。
pop()：如果 stack2 非空，直接从 stack2 弹出元素；如果 stack2 为空，将 stack1 的所有元素转移到 stack2 中，然后从 stack2 弹出元素。
peek()：如果 stack2 非空，直接返回 stack2 的栈顶元素；如果 stack2 为空，将 stack1 的所有元素转移到 stack2 中，然后返回 stack2 的栈顶元素。






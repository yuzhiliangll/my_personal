回顾:

里氏代换原则
所谓的里氏代换原则就是：子类类型必须能够替换掉他们的父类类型，而程序的行为不会发生任何改变。换句话说，子类对象应该能够替换其父类对象，而程序的功能不受影响。
里氏代换原则是实现开闭原则的重要方式之一，由于使用父类对象指针或引用的地方都可以使用子类对象来替代，因此在程序中尽量使用基类定义对象，而在运行时再确定其子类类型，用子类对象来替换父类对象。

如果不满足里氏代换原则, 则必然不满足依赖倒转原则


依赖倒转原则
1. 高层模块不应该依赖于底层模块，二者都应该依赖于抽象
2. 抽象不应该依赖于细节，细节应该依赖于抽象
3. 依赖倒转的中心思想是面向接口编程-- 多态


依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。
使用接口和抽象类规范而非具体类规范细节，程序中尽量使用抽象层，而少用具体类，多使用依赖倒转原则。


抽象类中提供的接口是固定不变的
低层模块是抽象类的子类, 继承了抽象类的接口, 并且可以重写这些接口的行为
高层模块想要实现某些功能, 调用的是抽象类中的函数接口,并且是通过抽象类的父类指针引用其子类的实例对象(用子类类型替换父类类型),这样就实现了多态

=================================================================================================================

在一个项目中，全局范围内，
某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局(间接)访问，
这种模式就叫单例模式。单例模式的典型应用就是任务队列。

2. 独生子女
如果使用单例模式，首先要保证这个类的实例有且仅有一个，也就是说这个对象是独生子女，如果我们实施计划生育只生一个孩子，不需要也不能给再他增加兄弟姐妹。
因此，就必须采取一系列的防护措施。对于类来说以上描述同样适用。

涉及一个类多对象操作的函数有以下几个：

构造函数：创建一个新的对象
拷贝构造函数：根据已有对象拷贝出一个新的对象
拷贝赋值操作符重载函数：两个对象之间的赋值
为了把一个类可以实例化多个对象的路堵死，可以做如下处理：

构造函数私有化，在类内部只调用一次，这个是可控的。

由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。
在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。
拷贝构造函数私有化或者禁用（使用 = delete）

拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）

由于单例模式就是给类创建一个唯一的实例对象，所以它的UML类图是很简单的：


因此，定义一个单例模式的类的示例代码如下：



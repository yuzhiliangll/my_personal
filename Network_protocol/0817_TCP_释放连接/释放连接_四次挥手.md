####  为什么释放连接的时候, 要进行4次挥手

TCP是 全双工模式 就意味着 数据可以在 两个方向上同时传输(同时进行)，所以关闭TCP连接需要四次挥手。

第一次挥手: 当主机1 发出 FIN 报文段时,
        表示主机1告诉主机2，主机1已经没有数据要发送了, 
        但是主机1还是可以接受来自主机2的数据。

第二次挥手: 当主机2 收到主机1的 FIN 报文段后，
        会发送一个 ACK 报文段给主机1，表示主机2已经收到了主机1的关闭请求
        但是主机2 还是可以发送数据到主机1的

第三次挥手: 当主机2会发送一个 FIN 报文段给主机1，
        表示主机2告诉主机1 已经没有数据要发送给主机1了。

第四次挥手: 当主机1 收到主机2的 FIN 报文段后，
        会发送一个 ACK 报文段给主机2，表示主机1已经知道主机2没有数据要发送了
        随后正式整个TCP连接关闭。

===========================================================================
================================================================================
在TCP协议中，连接的关闭采用“四次挥手”（Four-Way Handshake）的过程，这是因为TCP连接是全双工的，也就是说数据可以在同一时间在两个方向上传输。为了保证连接在双方都正确关闭的情况下，必须对两个方向的传输都进行确认和关闭操作。以下是详细的解释：

#### TCP连接的四次挥手过程
第一次挥手：客户端发送FIN（Finish）

当客户端想要关闭连接时，会发送一个带有 FIN 标志的TCP包，表示它已经没有数据要发送了，但仍然可以接收数据。
发送 FIN 后，客户端进入 FIN-WAIT-1 状态。
第二次挥手：服务器回送ACK（Acknowledgment）

服务器收到 FIN 后，确认收到了客户端的关闭请求，并发送一个带有 ACK 标志的TCP包，表示它已经收到 FIN。
服务器此时可能还有数据要发送，因此它不会立即关闭连接。
发送 ACK 后，服务器进入 CLOSE-WAIT 状态，客户端接收到 ACK 后进入 FIN-WAIT-2 状态。
第三次挥手：服务器发送FIN

服务器确定数据发送完毕后，会发送一个带有 FIN 标志的TCP包，表示它也准备关闭连接，停止数据发送。
发送 FIN 后，服务器进入 LAST-ACK 状态。
第四次挥手：客户端回送ACK

客户端收到服务器的 FIN 后，发送一个带有 ACK 标志的TCP包，表示确认关闭连接。
发送 ACK 后，客户端进入 TIME-WAIT 状态，此状态会持续一段时间（通常是两倍的最大报文段寿命，通常为2分钟），以确保服务器能收到 ACK 并最终关闭连接。
TIME-WAIT 状态结束后，客户端正式关闭连接，进入 CLOSED 状态。服务器在接收到客户端的 ACK 后，也会进入 CLOSED 状态，完成连接关闭。
为什么需要四次挥手
全双工通信：TCP是全双工模式，这意味着双方都可以独立地关闭各自的发送通道。发送方可以单独关闭其发送通道，而不影响接收通道的继续使用。

数据的可靠传输：在发送 FIN 标志后，接收方需要明确通知发送方已经收到了 FIN，以确保数据传输完成且所有数据都被接收方接收到。

确保可靠性和顺序性：每一次挥手都有明确的状态转换和等待机制，以确保双方都正确地收到对方的关闭请求，并且可以处理在此期间可能发生的任何数据传输。

总结
TCP连接的四次挥手过程是为了解决全双工通信中双方各自独立关闭发送通道的问题，确保连接的关闭过程是可靠且无误的。这种设计虽然增加了复杂性，但保证了网络通信的稳定性和数据的完整性。

============================================================================


使用三次或两次握手关闭TCP连接是不行的，这是因为TCP协议的全双工特性要求双方都独立地关闭各自的发送通道，并确认对方的关闭请求。四次挥手的过程确保了连接的双方都能够安全且有序地关闭连接，避免潜在的通信问题。以下是更详细的解释：

两次或三次挥手的潜在问题

#### 两次挥手的不足

无法保证数据完全传输：如果只使用两次挥手，假设客户端发送了 FIN 请求关闭连接，服务器回送 ACK 后立即关闭连接，这时如果服务器还有数据要发送，数据可能还未传输完毕或者未被客户端完全接收，连接就已经关闭了。这会导致数据丢失或不完整。
无法确认双方都已准备关闭：两次挥手无法分别处理双方的关闭意图，无法确认双方是否都准备好了关闭连接。

#### 三次挥手的不足

一方的关闭未被完全确认：如果使用三次挥手，例如客户端发送 FIN，服务器返回 ACK 并发送自己的 FIN，然后客户端再返回 ACK，这种情况下服务器的 FIN 可能还未被完全确认，服务器可能会认为连接仍然在继续，这会导致连接状态的不一致和资源的浪费。
忽略一方向另一方的单独关闭操作：三次挥手不足以分别确认和关闭双方的传输方向，会造成对方无法独立关闭其发送通道，也可能导致连接资源无法正确释放。
为什么四次挥手是必要的
独立关闭发送通道：在全双工通信中，双方的发送和接收通道是独立的。四次挥手确保每一方都能独立地关闭自己的发送通道，同时确认对方的关闭请求。

保证数据完整性：四次挥手允许双方在关闭连接前处理完所有待发送的数据，确保数据的完整性和正确接收。

状态同步：四次挥手中的每一步都对应着特定的连接状态转换，确保双方在关闭连接时状态同步，不会因为连接不一致而导致通信问题。

总结
使用四次挥手关闭TCP连接是为了满足TCP全双工通信的要求，确保数据传输的完整性和可靠性。两次或三次挥手无法提供同样的保障，可能导致数据丢失、连接不一致等问题，因此TCP协议设计为使用四次挥手来安全关闭连接。

=================================================================================

#### 最后发完ACK 为什么会有TIME_WAIT状态,还要等待2ms进入CLOSED状态

TIME_WAIT 状态是TCP协议中的一个关键设计，它出现在连接关闭的最后阶段，即客户端在发送完最后一个 ACK（确认）包之后进入 TIME_WAIT 状态。
TIME_WAIT 状态通常会持续2倍的最大报文段寿命（通常为2分钟，但可以根据实现不同而调整），之后才会进入最终的 CLOSED 状态。这个等待时间的设计有几个重要原因：

1. 确保最后的ACK包被对方收到
当客户端发送最后一个 ACK 包确认服务器的 FIN 请求后，服务器就认为连接已经成功关闭。
如果这个 ACK 包在传输过程中丢失，服务器会重发 FIN 包。
在 TIME_WAIT 状态下，客户端可以接收来自服务器的任何重发的 FIN 包，并重新发送 ACK 以确保服务器能够正确关闭连接。
如果没有 TIME_WAIT 状态，ACK 丢失后服务器重发的 FIN 包会无法得到回应，这可能会导致服务器认为连接未正确关闭，造成资源浪费。

2. 避免旧的重复数据包干扰新连接
TCP连接在网络中可能会遇到数据包延迟的情况，如果在连接关闭后立即使用相同的源和目标端口号重建新的连接，可能会出现前一个连接的旧数据包抵达并干扰新的连接。
TIME_WAIT 状态的持续时间足够长，可以确保旧的重复数据包在新连接建立前被丢弃，从而避免数据包混淆问题。

3. 保证连接的正确终止
在 TIME_WAIT 状态下，TCP协议确保连接的关闭是完全彻底的。
即使发生了任何意外情况，如丢包、网络延迟等，
TIME_WAIT 状态的存在可以保证这些情况不会影响连接的最终状态。
为什么是2倍的最大报文段寿命（MSL）
最大报文段寿命（MSL） 是一个TCP报文在网络中能存活的最长时间。通过等待2倍的MSL时间，可以确保所有与此连接相关的报文段都被正确接收或丢弃，从而避免报文段在网络中循环的可能性。

================================================================================================================================================================

CLOSING 状态在TCP连接的关闭过程中是一个相对少见但重要的状态。它出现在双方几乎同时发送 FIN 包的特殊情况下，以下是 CLOSING 状态的详细解释：

1. CLOSING 状态的产生
通常，在TCP连接的关闭过程中，一方先发送 FIN 包，然后另一方发送 FIN 包，双方分别进入 FIN-WAIT-1 和 CLOSE-WAIT 状态。
但在某些情况下，双方几乎同时决定关闭连接，并几乎同时发送 FIN 包。此时，双方在各自收到对方的 FIN 包之前，都处于 FIN-WAIT-1 状态。
当一方在 FIN-WAIT-1 状态下收到了对方的 FIN 包后，如果这时该方也已经发出了自己的 FIN 包（但尚未收到对方的 ACK），那么此时该方会进入 CLOSING 状态，而不是进入 FIN-WAIT-2 状态。
2. CLOSING 状态的意义
CLOSING 状态意味着TCP连接的双方都已经发送了 FIN 包，表示都想关闭连接。
在此状态下，TCP连接还未完全关闭，因为连接的一方还需要等待对方的 ACK 包以确认它的 FIN 包被对方接收。
3. CLOSING 状态的退出
当处于 CLOSING 状态的一方收到对方对其 FIN 包的 ACK 包后，它将进入 TIME_WAIT 状态。
TIME_WAIT 状态在此确保任何可能的 FIN 包重传都会得到正确的 ACK 响应，确保连接能被双方完全关闭。
4. CLOSING 状态的特殊性
CLOSING 状态出现的条件相对少见，因为它要求双方几乎同时发出 FIN 包。在大多数情况下，TCP连接关闭是由一方先发起的，所以 CLOSING 状态在实际应用中较少见。
简单总结
CLOSING 状态是TCP连接关闭过程中的一个中间状态，表示双方几乎同时发送了 FIN 包并正在等待对方的 ACK。它反映了TCP协议在处理连接关闭时的一种特殊情况，以确保双方都能够正确、安全地关闭连接。

===================================================================================

默认情况下TCP能等很久 甚至可以一直等下去

但是我们可以在灵活的在应用层 设置一个定时器
    加上的 心跳包的机制 使得连接保活

TCP的 keep-alive 和 HTTP 的keep-alive 是不一样的
在TCP中我们可以利用这个机制去设置 时长、心跳包
但是在开发当中我们一般不用

我们自己灵活的 自定义实现keep-alive
自定义实现 keep-alive 机制是为了在网络通信中检测和维护连接的活动状态。通常情况下，keep-alive 用于确保长时间空闲的连接依然有效，或者检测出连接已经断开。下面是一个简单的自定义 keep-alive 实现步骤：

1. 定义心跳包
首先，定义一个特定的消息格式或标识符，用于表示心跳包。心跳包通常是一个小的数据包，可以是一个简单的字符串（例如 "PING"）或特定的二进制数据。
2. 定期发送心跳包
在客户端或服务器一方，使用定时器定期发送心跳包。定时器的间隔时间应根据网络情况和应用需求进行调整，通常为几秒到几分钟不等。
如果在一段时间内没有发送或接收到数据，可以主动发送心跳包来确认连接状态。

```C++
void send_heartbeat(int sockfd) 
{
    const char *heartbeat = "PING";
    if (writen(sockfd, heartbeat, strlen(heartbeat)) < 0) 
    {
        perror("send heartbeat failed");
        // 处理发送失败的情况，例如重新连接
    }
}

3. 接收和响应心跳包
在另一方（通常是服务器端），需要监听并检测收到的心跳包。收到心跳包后，可以简单地返回一个响应（例如 "PONG"），表示连接仍然有效。

void handle_message(int sockfd, const char *msg) 
{
    if (strcmp(msg, "PING") == 0) 
    {
        const char *response = "PONG";
        if (writen(sockfd, response, strlen(response)) < 0) {
            perror("send pong failed");
            // 处理发送失败的情况
        }
    } 
    else 
    {
        // 处理其他正常消息
    }
}

4. 检测连接断开
在发送心跳包的一方，如果在设定的时间内没有收到对方的响应，可以认为连接可能已经断开。
可以使用计时器或超时机制来检测这种情况，一旦超时未收到响应，可以采取重新连接或释放资源的措施。
void check_connection_status(int sockfd) 
{
    int timeout = 5;  // 假设5秒未收到响应则认为连接断开
    fd_set readfds;
    struct timeval tv;
    FD_ZERO(&readfds);
    FD_SET(sockfd, &readfds);
    tv.tv_sec = timeout;
    tv.tv_usec = 0;
    int retval = select(sockfd + 1, &readfds, NULL, NULL, &tv);
    if (retval == -1) 
    {
        perror("select error");
    } 
    else if (retval == 0) 
    {
        printf("Connection timeout, no response\n");
        // 处理连接超时，例如重新连接
    } 
    else 
    {
        // 处理接收到的数据
    }
}

5. 处理网络异常
如果在发送心跳包或接收响应时检测到网络异常（如 write 或 read 失败），应立即尝试重新连接或其他故障恢复操作。

6. 调整 keep-alive 频率
根据实际情况调整心跳包的发送频率。频率过高会增加网络负担，过低则可能延迟检测到连接断开。

7. 扩展功能
你可以在心跳包中附加更多信息，如统计数据、状态信息等，以便在保持连接的同时传递额外的信息。
```
=================================================================
=================================================================



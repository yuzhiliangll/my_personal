在发送 HTTP 请求之前

得先建立--连接 -- 为什么是三次?

在三次握手的前两次 SYN 标志位是为 1 的

==========================================================================
==========================================================================================

三次握手连接之后, 发送HTTP 请求过去,包括--请求行、请求头、请求体等内容：
1. 请求行（Request Line）
请求行由三个部分组成：HTTP方法、请求的资源路径和HTTP版本。

HTTP方法：常见的方法包括 GET、POST、PUT、DELETE 等。例如，GET 表示请求资源，POST 表示提交数据。
资源路径：这是请求的资源在服务器上的路径。通常是URL中的路径部分。
HTTP版本：指定使用的HTTP协议版本，常见的是 HTTP/1.1。
GET /index.html HTTP/1.1

2. 请求头（Request Headers）
请求头包含了许多关于客户端环境和请求的元信息，如浏览器类型、主机名、内容类型等。每个请求头都是一个键值对的形式。

常见的请求头包括：

Host：请求的主机名和端口号。
User-Agent：客户端应用程序的信息（例如浏览器类型）。
Accept：客户端支持的响应内容类型。
Content-Type：发送请求的内容类型（通常在 POST 请求中使用）。
Content-Length：请求体的长度（通常在 POST 请求中使用）。
Connection：指定连接的类型，如 keep-alive 或 close。

Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8

3. 空行
请求头结束后，有一个空行，用来分隔请求头和请求体。空行只是一个回车符和换行符（\r\n）。

4. 请求体（Request Body）
请求体包含要发送到服务器的数据，通常在 POST、PUT 请求中使用。GET 请求通常不包含请求体。请求体的内容取决于请求的具体需求，比如提交表单数据、上传文件等。

示例（在 POST 请求中）：
name=JohnDoe&email=johndoe@example.com

5. 完整的HTTP请求示例
这是一个完整的HTTP请求示例，使用 POST 方法向服务器发送表单数据：
POST /submit-form HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Content-Type: application/x-www-form-urlencoded
Content-Length: 27
Connection: keep-alive

name=JohnDoe&email=johndoe@example.com

6. 服务器的响应
服务器在接收到HTTP请求后，会进行处理，并通过HTTP响应返回给客户端。
这包括状态行（如 HTTP/1.1 200 OK）、响应头、空行和响应体。

============================================================================================
=================================================================================================


序号  ：  是告诉对方 发送到哪了
确认号:   是告诉发送方 我已经收到了多少, 请接下来该发多少 
======================================================================================

序号和确认号的 原生值 是 在建立连接的时候 确定的

===============================================================================

详细给出该文件夹中图中的9个阶段来回的 序号确认号的原生值以及相对值的变化
这些图片显示了TCP连接中的序号和确认号的交互过程。为了详细解释每个阶段的序号（Sequence Number, Seq）和确认号（Acknowledgment Number, Ack），我们需要定义几个概念：

Seq（序号）：表示发送方发送的字节流的第一个字节的序号。
Ack（确认号）：表示接收方期望接收到的下一个字节的序号，即已经收到的最后一个字节的序号加1。

阶段详细解释
阶段① (A → B)

标志位：SYN=1, ACK=0
Seq (A)：设为 x（A 选择的初始序号）
Ack (A)：无效（因为 ACK=0）
阶段② (B → A)

标志位：SYN=1, ACK=1
Seq (B)：设为 y（B 选择的初始序号）
Ack (B)：x + 1（确认从 A 收到的 SYN，并期待从 A 收到的下一个序号）
阶段③ (A → B)

标志位：SYN=0, ACK=1
Seq (A)：x + 1（A 确认 SYN 之后发送的第一个字节）
Ack (A)：y + 1（确认从 B 收到的 SYN，并期待从 B 收到的下一个序号）
经过前三个阶段的交互，TCP三次握手成功，连接建立。

阶段④ (A → B)

HTTP 请求：A 向 B 发送HTTP请求。
Seq (A)：x + 1（继续从 x + 1 发送请求的第一个字节）
Ack (A)：y + 1（保持不变）
阶段⑤ (B → A)

标志位：ACK=1
Seq (B)：y + 1（B 确认 A 的数据）
Ack (B)：x + 1 + m（m 是 A 发送的 HTTP 请求数据的大小，表示 B 已经收到的最后一个字节的序号+1）
阶段⑥ (B → A)

标志位：ACK=1
Seq (B)：y + 1 或者 y + n（B 向 A 发送HTTP响应，n 是B发送的数据大小）
Ack (B)：x + 1 + m（保持不变）
阶段⑦ (A → B)

标志位：ACK=1
Seq (A)：x + 1 + m（A 向 B 确认已接收数据）
Ack (A)：y + 1 + n（确认 B 发送的 HTTP 响应数据）
阶段⑧ (B → A)

标志位：ACK=1
Seq (B)：y + 1 + n（B 向 A 确认数据）
Ack (B)：x + 1 + m（保持不变）
阶段⑨ (A → B)

标志位：ACK=1
Seq (A)：x + 1 + m（A 向 B 确认数据）
Ack (A)：y + 1 + n（保持不变）
总结
初始序号 x 和 y 是分别由 A 和 B 随机选择的初始序列号。
确认号 Ack 总是指示下一个期望收到的数据字节序号。
HTTP 请求和响应的过程中，Seq 和 Ack 随着数据传输不断增加。
每个阶段的序号和确认号的相对变化取决于各方传输的数据大小。

==========================================================================================

客户端的初始序号--ISN 将来是用在 服务器端的ACK号中的
服务器的初始序号      将来是用在 客户端的ACK号中的

===========================================================================================

为什么建立连接的时候, 要进行3次握手? 2次不行么?

TCP 建立连接时进行 3 次握手的原因主要是为了确保可靠的双向通信，并防止历史的重复连接请求对当前通信造成干扰。
具体原因如下：

1. 双向确认通信能力
第一次握手：客户端（A）向服务器（B）发送一个带有 SYN 标志的请求包，表示客户端希望建立连接，并告知客户端的初始序号（Seq=x）。
此时，客户端处于 SYN_SENT 状态。

这个消息的作用：客户端告诉服务器“我要和你建立连接，并且我可以发送数据。”

第二次握手：服务器（B）收到客户端的 SYN 请求后，确认自己收到了这个请求，于是发送一个带有 SYN 和 ACK 标志的响应包（SYN=1, ACK=1），
其中 Ack 表示确认收到客户端的 Seq，并包含服务器自己的初始序号（Seq=y）。
此时，服务器处于 SYN_RCVD 状态。

这个消息的作用：服务器告诉客户端“我收到了你的连接请求，你可以发送数据，我也准备好接收数据。”

第三次握手：客户端（A）收到服务器的 SYN+ACK 响应后，发送一个带有 ACK 标志的确认包，确认收到了服务器的 Seq（Ack=y+1）。
此时，客户端进入 ESTABLISHED 状态。
服务器在收到这个 ACK 后也进入 ESTABLISHED 状态，连接建立成功。

这个消息的作用：客户端告诉服务器“我收到了你确认的消息，现在可以正式开始通信。”

2. 防止历史重复连接的干扰
TCP 通过 3 次握手来确认双方都收到了对方的连接请求，并且还避免了历史的（老的或过期的）连接请求造成的误连接问题。假设有这样一种情况：

如果只进行 2 次握手，客户端向服务器发送了第一个 SYN 请求，而这个请求由于网络延迟等原因被延迟了（比如在很久之前的某个时间点发送的）。
服务器收到了 SYN，并回应一个 SYN+ACK，准备好建立连接。
但是此时客户端早已超时，并且不再等待服务器的响应，认为连接无法建立，放弃了这次连接请求。
服务器却认为连接已经建立，导致服务器资源被浪费。
通过 3 次握手，客户端在第三次握手中主动发送 ACK 以确认服务器的回应，这样双方都明确了对方当前的连接状态，从而避免了类似的问题。

为什么 2 次握手不够？
2 次握手无法确保双方都得知对方已经准备好建立连接。
例如，如果只进行 2 次握手，那么就无法确认客户端是否成功收到了服务器的 SYN+ACK，从而无法确保双方都能可靠地开始数据传输。

=====================================================================================================

为什么建立连接的时候, 要进行3次握手? 2次不行么?

主要目的: 防止server 端一直等待, 浪费资源

如果建立连接只需要2次握手, 可能会出现的情况：

假设 client 发出的第一个连接请求报文段, 因为网络延迟, 
在连接释放以后的某个时间才到达server 端，
本来这是一个早已失效的连接请求,  但服务器端收到失效的请求后, 会误认为这是client 再发出的 全新的连接请求
但是客户端是不会响应此时服务器端的应答,因为这不是我想要的
因为在连接释放之前客户端已经得到了自己想要的
------而此时因为两次握手 服务器认为我已经建立了连接, 所以会一直等待客户端的响应, 
------导致server端一直浪费资源

==================================================================================
==================================================================================


第3次握手失败了, 会怎么处理?

此时 server 的状态为SYN-RECV , 若等不到client 的 ACK ，server 会重新发送 SYN+ACK 包 给 client
如果server 多次重发 SYN+ACK 等不到client 的ACK , 就会发送 RST 包, 强制关闭连接

在TCP三次握手过程中，如果第三次握手失败（即客户端未能成功发送ACK或服务器未能接收到ACK），
连接的建立将失败。根据具体情况，会有以下几种处理方式：

1. 客户端的处理
超时重传：如果客户端发送的第三个ACK未收到服务器的响应（可能是因为网络故障、服务器崩溃等），
客户端会等待一个超时时间。
超时后，客户端可能会重试发送ACK包。
TCP协议允许多次重传来确保通信的可靠性。

放弃连接：如果经过多次重试后仍未收到服务器的确认响应，
客户端会认为连接建立失败，进入CLOSED状态，并放弃建立连接。
此时，客户端可能会返回错误信息或提示用户连接失败。

2. 服务器的处理
等待ACK超时：服务器在第二次握手后，等待接收客户端的ACK。如果在设定的超时时间内未收到ACK，服务器会认为客户端可能没有收到服务器的SYN+ACK，或者客户端无法回复ACK。

释放资源：如果服务器超时后仍未收到ACK，服务器将会中止连接的建立，释放已分配的资源（如内存、连接状态等），进入LISTEN状态，准备接受新的连接请求。

3. 潜在的影响
半开连接：如果服务器没有检测到ACK丢失，并继续认为连接已建立，这可能会导致一种“半开连接”的情况。这种连接会占用服务器资源，但实际上客户端并未完成连接建立。大多数现代的TCP实现中，服务器会设置一定的超时时间，在未收到ACK的情况下自动关闭这种“半开连接”。

客户端资源浪费：同理，如果客户端多次重传ACK但始终未收到服务器的响应，客户端也会耗费资源在无效的连接尝试上。客户端最终也会超时放弃并关闭连接。

4. 自动重连机制
在一些高层协议或应用程序中，可能会实现自动重连机制。如果检测到TCP连接失败，客户端会自动尝试重新建立连接。这通常是通过多次重新发送连接请求来实现的。

总结
当第三次握手失败时，TCP会根据超时和重传机制来处理连接失败。最终，如果无法完成三次握手，连接将不会建立，双方都会释放资源并返回到初始状态，允许再次尝试建立连接或处理连接失败的情况。


